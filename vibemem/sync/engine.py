"""Sync engine for generating tool-specific config files."""

from pathlib import Path
from typing import Dict, List, Any, Optional
from ..core.memory import MemoryStore
from ..core.config import Config
from ..core.tokens import TokenCounter, CompressionStrategy


class ToolAdapter:
    """Base adapter for AI coding tools."""

    name: str = "base"
    config_file: str = ""
    default_budget: int = 4000

    def __init__(self, project_path: Path, config: Config):
        self.project_path = project_path
        self.config = config
        self.budget = config.get_budget(self.name)

    def detect(self) -> bool:
        """Detect if this tool is used in the project."""
        return True  # Default: always generate

    def get_output_path(self) -> Path:
        """Get path to write config file."""
        return self.project_path / self.config_file

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        """Format memories for this tool."""
        raise NotImplementedError

    def write(self, content: str, dry_run: bool = False) -> Dict[str, Any]:
        """Write formatted content to config file."""
        path = self.get_output_path()
        tokens = TokenCounter.count(content)

        result = {
            "success": True,
            "path": str(path),
            "tokens": tokens,
        }

        if not dry_run:
            path.parent.mkdir(parents=True, exist_ok=True)
            with open(path, "w") as f:
                f.write(content)

        return result


class ClaudeCodeAdapter(ToolAdapter):
    """Adapter for Claude Code (CLAUDE.md)."""

    name = "claude-code"
    config_file = "CLAUDE.md"
    default_budget = 10000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        all_memories = memories + global_memories

        # Compress to fit budget
        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget,
            preserve_categories=self.config.compression.get("preserve_categories", [])
        )

        lines = [
            "# Project Memory (vibemem)",
            "",
            "> Auto-generated by vibemem. Do not edit directly.",
            "> Run `vibemem add <category> <content>` to add memories.",
            "",
        ]

        # Group by category
        by_category = {}
        for item in compressed:
            cat = item["category"]
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(item)

        # Critical items first
        if "critical" in by_category or any(m["priority"] == "critical" for m in compressed):
            lines.append("## Critical")
            for item in compressed:
                if item["priority"] == "critical":
                    lines.append(f"- **{item['content']}**")
            lines.append("")

        # Then by category
        for category in sorted(by_category.keys()):
            if category == "critical":
                continue
            items = by_category[category]
            lines.append(f"## {category.title()}")
            for item in items:
                if item["priority"] != "critical":
                    prefix = "[!] " if item["priority"] == "critical" else ""
                    lines.append(f"- {prefix}{item['content']}")
            lines.append("")

        return "\n".join(lines)


class CursorAdapter(ToolAdapter):
    """Adapter for Cursor (.cursorrules)."""

    name = "cursor"
    config_file = ".cursorrules"
    default_budget = 6000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        all_memories = memories + global_memories

        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget,
            preserve_categories=self.config.compression.get("preserve_categories", [])
        )

        lines = [
            "# Project Context (vibemem)",
            "",
        ]

        # Group by category
        by_category = {}
        for item in compressed:
            cat = item["category"]
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(item)

        for category in sorted(by_category.keys()):
            items = by_category[category]
            lines.append(f"## {category.title()}")
            for item in items:
                lines.append(f"- {item['content']}")
            lines.append("")

        return "\n".join(lines)


class CopilotAdapter(ToolAdapter):
    """Adapter for GitHub Copilot (.github/copilot-instructions.md)."""

    name = "copilot"
    config_file = ".github/copilot-instructions.md"
    default_budget = 3000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        all_memories = memories + global_memories

        # More aggressive compression for Copilot's smaller budget
        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget,
            preserve_categories=["critical", "arch"]
        )

        lines = [
            "# Project Context",
            "",
        ]

        for item in compressed:
            lines.append(f"- {item['content']}")

        return "\n".join(lines)


class AiderAdapter(ToolAdapter):
    """Adapter for Aider (.aider.conf.yml)."""

    name = "aider"
    config_file = ".aider.conf.yml"
    default_budget = 4000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        import yaml

        all_memories = memories + global_memories

        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget - 100,  # Reserve for YAML structure
            preserve_categories=self.config.compression.get("preserve_categories", [])
        )

        # Build context string
        context_lines = ["Project context (from vibemem):"]
        for item in compressed:
            context_lines.append(f"- [{item['category']}] {item['content']}")

        context = "\n".join(context_lines)

        config = {
            "read": [".vibemem/hot.md"],
            "system-prompt": context,
        }

        return yaml.dump(config, default_flow_style=False)


class WindsurfAdapter(ToolAdapter):
    """Adapter for Windsurf (.windsurfrules)."""

    name = "windsurf"
    config_file = ".windsurfrules"
    default_budget = 5000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        all_memories = memories + global_memories

        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget,
            preserve_categories=self.config.compression.get("preserve_categories", [])
        )

        lines = ["# Project Memory (vibemem)", ""]

        by_category = {}
        for item in compressed:
            cat = item["category"]
            if cat not in by_category:
                by_category[cat] = []
            by_category[cat].append(item)

        for category in sorted(by_category.keys()):
            items = by_category[category]
            lines.append(f"## {category.title()}")
            for item in items:
                lines.append(f"- {item['content']}")
            lines.append("")

        return "\n".join(lines)


class ClineAdapter(ToolAdapter):
    """Adapter for Cline (.clinerules)."""

    name = "cline"
    config_file = ".clinerules"
    default_budget = 5000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        all_memories = memories + global_memories

        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget,
            preserve_categories=self.config.compression.get("preserve_categories", [])
        )

        lines = ["# Project Context", ""]

        for item in compressed:
            lines.append(f"- [{item['category']}] {item['content']}")

        return "\n".join(lines)


class ContinueAdapter(ToolAdapter):
    """Adapter for Continue (.continue/config.json rules)."""

    name = "continue"
    config_file = ".continuerules"
    default_budget = 4000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        all_memories = memories + global_memories

        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget,
            preserve_categories=self.config.compression.get("preserve_categories", [])
        )

        lines = ["# Project Memory", ""]

        for item in compressed:
            lines.append(f"- {item['content']}")

        return "\n".join(lines)


class ZedAdapter(ToolAdapter):
    """Adapter for Zed AI (.zed/settings.json)."""

    name = "zed"
    config_file = ".zed/prompt.md"
    default_budget = 4000

    def format(self, memories: List[Dict[str, Any]], global_memories: List[Dict[str, Any]]) -> str:
        all_memories = memories + global_memories

        compressed = CompressionStrategy.smart_compress(
            all_memories,
            self.budget,
            preserve_categories=self.config.compression.get("preserve_categories", [])
        )

        lines = ["# Project Context", ""]

        for item in compressed:
            lines.append(f"- {item['content']}")

        return "\n".join(lines)


# Registry of all adapters
ADAPTERS = {
    "claude-code": ClaudeCodeAdapter,
    "cursor": CursorAdapter,
    "copilot": CopilotAdapter,
    "aider": AiderAdapter,
    "windsurf": WindsurfAdapter,
    "cline": ClineAdapter,
    "continue": ContinueAdapter,
    "zed": ZedAdapter,
}


class SyncEngine:
    """Engine for syncing memories to all tools."""

    def __init__(self, project_path: Optional[Path] = None):
        self.project_path = project_path or Path.cwd()
        self.config = Config.load(self.project_path)

    def get_adapters(self, tools: Optional[List[str]] = None) -> List[ToolAdapter]:
        """Get adapters for specified tools or all detected tools."""
        if tools:
            return [
                ADAPTERS[t](self.project_path, self.config)
                for t in tools
                if t in ADAPTERS
            ]

        # Auto-detect or return all
        if self.config.sync.get("auto_detect_tools", True):
            adapters = []
            for name, cls in ADAPTERS.items():
                adapter = cls(self.project_path, self.config)
                if adapter.detect():
                    adapters.append(adapter)
            return adapters

        return [cls(self.project_path, self.config) for cls in ADAPTERS.values()]

    def sync(
        self,
        tools: Optional[List[str]] = None,
        dry_run: bool = False
    ) -> Dict[str, Dict[str, Any]]:
        """Sync memories to all tools."""
        # Load memories
        project_store = MemoryStore.load(project_path=self.project_path)
        global_store = MemoryStore.load(is_global=True)

        project_memories = project_store.list()
        global_memories = global_store.list() if self.config.sync.get("include_global", True) else []

        # Sync to each tool
        results = {}
        adapters = self.get_adapters(tools)

        for adapter in adapters:
            try:
                content = adapter.format(project_memories, global_memories)
                original_tokens = TokenCounter.count(content)

                result = adapter.write(content, dry_run=dry_run)
                result["original_tokens"] = original_tokens
                result["compressed"] = result["tokens"] < original_tokens

                results[adapter.name] = result

            except Exception as e:
                results[adapter.name] = {
                    "success": False,
                    "error": str(e),
                    "path": str(adapter.get_output_path()),
                    "tokens": 0,
                }

        return results
